# Контекст выполнения в JavaScript

## Виды контекста выполнения

### 1. Глобальный контекст выполнения

- **Глобальный контекст** создается при загрузке скрипта и применяется ко всему коду, который выполняется вне функций.
- В глобальном контексте значение `this` зависит от режима работы:
  - В **строгом режиме** (`use strict`) значение `this` будет `undefined`.
  - В нестрогом режиме значение `this` ссылается на глобальный объект (`window` в браузере или `global` в Node.js).
- В программе может существовать только один глобальный контекст.

### 2. Функциональный контекст выполнения

- **Функциональный контекст** создается каждый раз при вызове функции.
- Каждая функция имеет свой собственный контекст выполнения.
- В функциональном контексте значение `this` определяется тем, как была вызвана функция:
  - Если функция вызвана как метод объекта, то `this` указывает на этот объект.
  - Если функция вызвана в глобальном контексте, то `this` указывает на глобальный объект (в строгом режиме – `undefined`).

### 3. Контекст выполнения `eval`

- Контекст выполнения создается для кода внутри функции `eval`. Он может изменять существующие переменные в локальной области видимости.

## Составляющие контекста выполнения

Когда создается контекст выполнения, выполняются следующие шаги:

1. **Определение значения `this` и привязка его к текущему контексту.**

   - В глобальном контексте `this` ссылается на глобальный объект.
   - В функциональном контексте значение `this` зависит от того, как была вызвана функция.

2. **Создание компонента `LexicalEnvironment` (лексическое окружение).**

   - Лексическое окружение – это структура, которая хранит идентификаторы переменных, их значения и ссылки на внешнее окружение.

3. **Создание компонента `VariableEnvironment` (окружение переменных).**
   - Это окружение хранит все переменные, объявленные внутри контекста выполнения.

### Контекст выполнения концептуально

```javascript
ExecutionContext = {
  ThisBinding: <this value>,
  LexicalEnvironment: { ... },
  VariableEnvironment: { ... },
}
```

# Методы управления контекстом выполнения в JavaScript

## Методы изменения контекста

### 1. `call(context, arg1, arg2, ...)`

- Метод `call` вызывает функцию с явно указанным контекстом `this` и передает аргументы через запятую.
- Используется, когда нужно явно задать значение `this` в момент вызова функции.

```javascript
function greet(greeting) {
  console.log(`${greeting}, ${this.name}`);
}

const user = { name: "John" };
greet.call(user, "Hello"); // Output: Hello, John
```

### 2. apply(context, [arg1, arg2, ...])

    - Метод apply вызывает функцию с явно указанным контекстом `this`, но аргументы передаются в виде массива.
    - Это удобно, когда количество аргументов заранее неизвестно или они уже находятся в массиве.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}${punctuation}`);
}

const user = { name: "John" };
greet.apply(user, ["Hello", "!"]); // Output: Hello, John!
```

### 3. bind(context)

    - Метод `bind` создает новую функцию, привязанную к указанному контексту this. Эту функцию можно вызвать позже.
    - Это полезно, когда нужно привязать контекст функции на будущее.

```javascript
function greet() {
  console.log(this.name);
}

const user = { name: "John" };
const boundGreet = greet.bind(user);
boundGreet(); // Output: John
```

## Игнорирование контекста

    - Если необходимо проигнорировать контекст, можно передать `null` или `undefined` в качестве первого аргумента.
    - В строгом режиме` (use strict)`, значение `this` будет `undefined`. В нестрогом режиме значение `this` ссылается на глобальный объект.

```javascript
function greet() {
  console.log(this.name);
}

greet.call(null); // В строгом режиме: undefined
// В нестрогом режиме: ссылается на глобальный объект (например, `window`)
```

### Пример использования методов управления контекстом

```javascript
function greet() {
  console.log(this.name);
}

const user = { name: "John" };

// Использование метода `call`
greet.call(user); // Output: John – this ссылается на объект user

// Использование метода `apply`
greet.apply(user); // Output: John

// Использование метода `bind`
const boundGreet = greet.bind(user);
boundGreet(); // Output: John

// Игнорирование контекста
greet.call(null); // В строгом режиме this будет undefined
```
