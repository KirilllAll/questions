# 1. Загрузка и парсинг HTML

## Загрузка HTML:

**Тип запроса**: Браузер отправляет `HTTP GET` запрос на сервер для получения HTML-документа. Запрос включает заголовки (headers), информацию о кэше и данные о клиенте (user-agent), чтобы сервер мог понять, как отправить правильный ответ.

**Когда запрос отправляется**: После завершения DNS-резолюции и установления соединения браузер отправляет запрос на получение главного HTML-файла, который загружается, начиная процесс рендеринга.

---

## Парсинг HTML:

Процесс парсинга HTML — это основной этап, когда текстовый HTML-документ разбирается на структурированные элементы, которые браузер может визуализировать. Давайте подробнее разберем, как это происходит.

### 1. Токенизация:

Токенизация — это первый этап парсинга, при котором HTML-документ разбивается на небольшие структурированные компоненты, называемые токенами. Каждый токен — это базовый строительный блок HTML, например, открывающий тег `<div>`, закрывающий тег `</div>`, текст внутри тега и атрибуты.

#### Примеры токенов:

- Открывающий тег: `<html>`, `<body>`, `<p>`

- Закрывающий тег: `</html>`, `</body>`, `</p>`

- Текст: любой текстовый контент внутри тега

---

## 2. Создание нод:

После того, как HTML-документ был токенизирован, браузер переходит к созданию нод (узлов), которые формируют DOM (Document Object Model). Каждая нода представляет собой либо элемент (например, тег), либо текст, либо комментарий.

## Из чего состоит нода:

- **Элемент ноды**: Узлы, которые представляют HTML-теги, такие как `<div>`, `<p>`, `<h1>`. Эти узлы могут содержать атрибуты, например, `id`, `class` или `style`.

- **Текстовые ноды**: Узлы, которые представляют текстовый контент между тегами.

- **Атрибуты ноды**: Свойства элементов, такие как `id="header"`, `class="container"`.

#### Структура дерева:

DOM организован в виде дерева, где родительские элементы могут иметь дочерние элементы (узлы). Например:

```html
<div>
  <p>Hello, World!</p>
</div>
```

В этом примере <div> является родительским элементом, а <p> — его дочерним.

---

### 3. Обработка <head>:

Тег <head> — это особая часть `HTML`-документа, которая содержит метаданные о странице и ссылки на внешние ресурсы, такие как стили и скрипты. Во время парсинга браузер обрабатывает содержимое тега <head>, чтобы правильно загрузить и использовать эти ресурсы.

Что содержится в <head>: - Метатеги: Теги <meta> предоставляют информацию о кодировке, авторе, описании страницы и т.д. - Теги <title>: Определяют заголовок страницы, который отображается в заголовке вкладки браузера. - Теги <link>: Подключают внешние ресурсы, такие как `CSS`-файлы, иконки для страницы. - Теги <script>: Скрипты `JavaScript`, которые могут быть либо загружены с внешнего URL, либо встроены прямо в документ.

**Важно:** Браузер начинает загружать ресурсы, указанные в <head>, еще до того, как весь HTML-документ полностью загружен.

Зачем нужен <head>: - Оптимизация загрузки: Включение ссылок на `CSS` и `JavaScript` в <head> позволяет браузеру заранее загружать и кешировать эти файлы, тем самым ускоряя процесс рендеринга страницы.

---

## 4. Обнаружение блокирующих ресурсов:

В процессе парсинга, если браузер встречает блокирующие ресурсы, такие как синхронные скрипты (тег <script> без атрибута `async` или `defer`), он приостанавливает парсинг `HTML` до тех пор, пока не завершит загрузку и выполнение этих ресурсов. Это важно учитывать для оптимизации загрузки страницы, так как такие ресурсы могут замедлить весь процесс рендеринга.

# 2. Загрузка и парсинг CSS

## Загрузка CSS:

**Тип запроса**:

Браузер отправляет HTTP GET запросы для загрузки всех файлов стилей, на которые ссылается HTML-документ через теги `<link rel="stylesheet">` или стили, встроенные через тег `<style>`. Если стили подключены через абсолютные или относительные URL-адреса, это инициирует запросы к серверу для их получения.

**Когда запрос отправляется**:

Запросы на CSS-файлы отправляются немедленно после их обнаружения в процессе парсинга HTML. Загрузка CSS происходит параллельно с парсингом других частей HTML-документа, но браузер **не может продолжить визуализацию страницы**, пока все CSS-файлы не будут загружены и завершен их парсинг.

## Парсинг CSS:

**Когда начинается парсинг**:

Как только CSS-файл загружен, браузер немедленно начинает его парсинг. Парсинг CSS выполняется для преобразования текстовых CSS-правил в структурированные данные, создавая дерево объектов, известное как CSSOM (CSS Object Model).

## Создание CSSOM:

CSSOM представляет собой древовидную структуру, которая содержит информацию о том, как стили применяются к элементам DOM. Это важно, потому что только после завершения создания CSSOM браузер может приступить к формированию Render Tree — структуры, которая используется для визуализации страницы.

### Расчет селекторов:

Во время парсинга браузер выполняет процесс расчета селекторов, чтобы определить, как CSS-правила применяются к элементам DOM. Этот процесс включает:

- **Проверку каждого селектора** в CSS-файле и сопоставление его с элементами DOM.

- **Приоритетность CSS-правил** (Specificity), что определяет, какое правило будет применено, если несколько селекторов влияют на один и тот же элемент.

## Когда отрисовка стилей может блокировать рендер:

Отрисовка стилей может блокировать рендеринг страницы, если браузер не завершил загрузку и парсинг всех CSS-файлов. Это происходит потому, что браузер не может построить Render Tree до тех пор, пока CSSOM не будет полностью создан. Внешние CSS-файлы (например, через `<link rel="stylesheet">`) являются **блокирующими ресурсами**, что означает, что браузер приостанавливает рендеринг до завершения их загрузки и парсинга. Однако можно избежать этого, используя атрибуты `media="print"` или `media="screen and (max-width: ...)` для отложенной загрузки стилей, либо использовать асинхронную загрузку стилей.

# 3. Создание Render Tree

Render Tree (дерево рендеринга) — это структура, созданная браузером на основе DOM и CSSOM. Она содержит только те элементы, которые будут визуализированы на экране. Элементы, скрытые с помощью CSS (например, `display: none`), исключаются из Render Tree. Этот процесс можно разбить на несколько этапов.

## Этапы создания Render Tree:

1.  **Объединение DOM и CSSOM**:

- Браузер начинает процесс объединения **DOM** (Document Object Model), который описывает структуру HTML, и **CSSOM** (CSS Object Model), который содержит стили, применяемые к элементам DOM.

- **DOM** — это дерево всех HTML-элементов, в том числе тех, которые могут не отображаться на странице.

- **CSSOM** описывает стили, такие как цвета, размеры, отступы, примененные к элементам DOM.

2.  **Пропуск невидимых элементов**:

- В процессе создания Render Tree браузер исключает элементы, которые не будут отображаться на странице. Например, элементы с `display: none` исключаются, так как они не занимают места на странице.

- Однако элементы, скрытые через `visibility: hidden`, остаются в Render Tree, так как они занимают место, хоть и не видны пользователю.

3.  **Создание визуальных объектов**:

- Для каждого отображаемого элемента браузер создает "визуальный объект" (render object), который хранит информацию о том, как этот элемент будет отображаться: его размеры, позицию, стили (например, цвет, шрифт, фон).

- Браузер вычисляет стили, основываясь на специфичности CSS-селекторов и наследовании стилей.

4.  **Иерархия и порядок элементов**:

- Порядок элементов в Render Tree соответствует их иерархии в DOM, а также их визуальному расположению в потоке документа. Браузер учитывает CSS-стили, такие как `float`, `position`, `flex`, для определения финального расположения элементов на странице.

5.  **Зависимость от шрифтов и других внешних ресурсов**:

- Если для элементов нужны шрифты или изображения, которые еще не загружены, браузер может задержать окончательное построение Render Tree до получения этих ресурсов. Например, отсутствие ключевых шрифтов может влиять на финальный рендер текста.

## Результат:

Render Tree содержит информацию только о тех элементах, которые должны быть отображены на экране. Эта структура используется на последующих этапах рендеринга для расчета макета и отрисовки элементов страницы.

Пример:

```html
<div style="display: none">
  <p>This paragraph will not appear in the Render Tree</p>
</div>

<div style="visibility: hidden">
  <p>This paragraph will be in the Render Tree but not visible</p>
</div>
```

В этом примере первый <div> и его содержимое не будут отображаться в Render Tree, а второй <div> попадет в дерево рендеринга, хотя он невидим.

Этот процесс подготовки Render Tree является важным шагом в оптимизации рендеринга и управления производительностью страницы, так как помогает браузеру фокусироваться только на видимых элементах.

# 4. Расчет макета (Layout / Reflow)

Этап **Layout**, также известный как **Reflow**, — это процесс, в ходе которого браузер определяет размер, положение и геометрию всех элементов на странице. Это важный и ресурсоемкий этап, так как от его эффективности зависит производительность рендеринга страницы. Layout выполняется после создания **Render Tree** и перед отрисовкой элементов на экране.

## Основные этапы процесса Reflow:

1.  **Построение геометрической модели элементов**:

- Браузер просматривает **Render Tree**, чтобы рассчитать размеры и позиции всех видимых элементов. Эти расчеты основываются на стилях, таких как:

- `width`, `height` — размеры элементов;

- `margin`, `padding`, `border` — отступы и границы;

- `position` — позиционирование (относительное, абсолютное или фиксированное).

- Каждый элемент получает свои конечные размеры и координаты в зависимости от стилей и влияния окружающих элементов.

2.  **Поток документа**:

- Браузер начинает расчет с корневого элемента (обычно `<html>`) и идет по всему дереву, определяя размеры и положение каждого элемента.

- Для элементов с позиционированием по умолчанию (обычный поток документа) браузер рассчитывает их размеры и отступы в соответствии с моделью потока. Например, блоки занимают всю ширину контейнера, а строчные элементы располагаются горизонтально.

3.  **Обработка вложенности элементов**:

- Вложенные элементы рассчитываются с учетом родительских элементов. Например, дочерний элемент будет ограничен размерами и границами своего родителя. Это особенно важно при использовании контейнеров с `padding` и `border`, а также при работе с `flex` или `grid` контейнерами.

- Позиционирование элементов может зависеть от того, как позиционированы их родительские контейнеры. Например, если родительский элемент имеет `position: relative`, дочерние элементы с `position: absolute` будут позиционироваться относительно родителя.

4.  **Ограничения и выравнивание**:

- Браузер учитывает такие стили, как `min-width`, `max-width`, `min-height` и `max-height`, чтобы ограничить размеры элементов.

- CSS-свойства, отвечающие за выравнивание, такие как `text-align`, `vertical-align`, `justify-content`, также влияют на конечный вид и расположение элементов.

5.  **Layout для специальных элементов**:

- Элементы с нестандартным поведением, такие как таблицы, элементы с `float`, `flex` и `grid`, требуют более сложных вычислений, так как они влияют на окружающие элементы. Например:

- Элементы с `float` "выталкиваются" из обычного потока документа и могут пересекаться с другими элементами.

- Элементы в `flex`-контейнерах распределяются вдоль главной оси в зависимости от их размеров и содержимого.

- Таблицы требуют сложного процесса расчета для распределения строк и ячеек.

6.  **Переход от Render Tree к визуальной модели**:

- По завершению layout браузер формирует готовую визуальную модель страницы, где каждый элемент имеет определенные размеры и положение на экране.

## Процесс Reflow:

Reflow может происходить как на этапе первого рендеринга страницы, так и повторно, если структура DOM или CSS изменяется в процессе работы страницы. Например, изменение стилей или добавление новых элементов может вызвать перерасчет макета для части или всей страницы.

## Когда происходит повторный Reflow:

1.  **Изменения в DOM**:

- Вставка, удаление или перемещение элементов в DOM может инициировать Reflow. Например, добавление нового блока текста или изображения потребует перерасчета макета.

2.  **Изменения в стилях**:

- Изменение CSS-свойств, влияющих на геометрию элементов, таких как `width`, `height`, `padding`, `margin`, `display`, `position`, вызовет Reflow. Например, если JavaScript динамически изменяет `style.width`, браузер должен заново рассчитать макет.

3.  **Изменение размеров окна браузера**:

- Когда пользователь изменяет размер окна браузера, браузер должен пересчитать макет, чтобы все элементы правильно отобразились в новом размере.

4.  **Изменение шрифтов или их загрузка**:

- Загрузка шрифтов может повлиять на размеры текстовых элементов, что приведет к повторному Reflow, особенно если шрифт имеет другую метрику.

## Влияние Reflow на производительность:

Reflow может быть весьма затратным по ресурсам процессом, особенно если изменения в одном элементе требуют перерасчета макета для всего документа. Этот процесс может занимать значительное количество времени и негативно сказываться на производительности страницы.

## Способы оптимизации Reflow:

1.  **Минимизация изменений в DOM**:

- Избегайте частого добавления, удаления или перемещения элементов в DOM. Вместо этого изменяйте элементы одним блоком или используйте технику "внеэкранного" обновления (например, через `documentFragment`).

2.  **Использование CSS-классов вместо инлайн-стилей**:

- Вместо динамического изменения стилей с помощью JavaScript лучше менять классы, что позволяет избежать множества изменений стилей и уменьшает вероятность Reflow.

3.  **Избегание повторных операций с DOM**:

- Операции с DOM (например, изменение стилей или содержимого) могут вызывать повторные reflow и repaint. Их можно объединить и выполнять пакетно, чтобы уменьшить количество перерасчетов.

4.  **Изменение невидимых элементов**:

- Если необходимо изменить элемент, временно сделайте его невидимым (`display: none`), внесите изменения и затем верните его на страницу. Элементы с `display: none` не влияют на макет и не вызывают reflow.

5.  **Использование `will-change`**:

- Для анимаций или часто изменяющихся элементов укажите свойство CSS `will-change`, которое сообщает браузеру, что элементы будут изменяться, и помогает ему оптимизировать процесс Reflow и Repaint.

6.  **Работа с анимациями**:

- Избегайте анимаций, которые напрямую влияют на layout, таких как изменение размера или положения элементов. Лучше анимировать непрерывные свойства, как `transform` или `opacity`.

## Заключение:

Reflow — это критический этап рендеринга страницы, когда браузер рассчитывает размеры и позиции всех элементов на основе их стилей. Повторные вызовы Reflow могут значительно замедлить работу страницы, особенно на мобильных устройствах. Оптимизация этого процесса — важный аспект повышения производительности веб-приложений.

# 5. Отрисовка (Painting)

Этап **отрисовки (Painting)** — это процесс, когда браузер визуализирует страницу на экране, заполняя элементы цветами, изображениями, границами, тенями и другими графическими эффектами. На этом этапе **Render Tree** преобразуется в набор пикселей, которые затем отображаются на экране.

## Основные этапы процесса отрисовки:

1.  **Сбор информации для отрисовки**:

- После того как **Render Tree** завершён и все элементы получили свои размеры и позиции (после **Layout/Reflow**), браузер приступает к сбору информации о том, как каждый элемент должен быть визуализирован.

- Каждый элемент в **Render Tree** содержит информацию о стилях: цвет фона (`background-color`), цвет текста (`color`), границы (`border`), тени (`box-shadow`), фоновое изображение и другие визуальные эффекты.

2.  **Слои отрисовки**:

- Для упрощения отрисовки, браузер может разделить элементы на слои. Слои позволяют улучшить производительность, так как браузер может перерисовывать только измененные части страницы, не затрагивая другие элементы.

- Создание слоёв может быть вызвано такими стилями, как `z-index`, `position: fixed/absolute`, `transform`, `opacity`, или при использовании сложных CSS-анимаций.

3.  **Rasterization (Растеризация)**:

- После разделения на слои, каждый слой отрисовывается в пиксели. Этот процесс называется **rasterization** (растеризация).

- Браузер вычисляет, какие пиксели на экране должны быть закрашены и каким цветом. Этап растеризации включает прорисовку всех текстур, теней, градиентов, изображений и других визуальных эффектов.

4.  **Композиция слоёв**:

- После того как каждый слой был растеризован, браузер компилирует все слои, собирая их в финальное изображение.

- Этот процесс называется **compositing** (компоновка). Он включает в себя объединение слоев с учетом их наложения, прозрачности и других визуальных эффектов.

## Отрисовка во время ререндера (Repaint):

**Repaint** — это процесс перерисовки частей страницы, который происходит в случае изменений, не затрагивающих размер или положение элементов, но влияющих на их визуальное отображение. Это может включать:

- Изменение цвета текста или фона (`color`, `background-color`);

- Добавление или изменение теней (`box-shadow`, `text-shadow`);

- Изменение границ (`border`);

- Изменение прозрачности (`opacity`).

## Основные сценарии Repaint:

1.  **Изменение визуальных стилей**:

- Если изменяется стиль элемента, например, цвет текста или фона, браузер перерисовывает только измененную область. Например, если пользователь наводит курсор на элемент с эффектом `hover`, и цвет элемента меняется, произойдет **repaint** для перерисовки элемента с новым стилем.

2.  **Работа с невидимыми элементами**:

- Элементы, которые скрыты с помощью `visibility: hidden`, по-прежнему занимают место в потоке документа, но не отображаются. Если видимость элемента изменится на `visibility: visible`, произойдет **repaint**, так как элемент станет видимым, но его позиция и размеры останутся теми же.

3.  **Изменение прозрачности**:

- Изменение прозрачности (`opacity`) вызывает **repaint**, так как браузер должен изменить визуальное представление элемента, даже если его размеры остаются неизменными.

## Как отрисовка влияет на производительность:

**Repaint** менее затратен, чем **reflow**, так как он не требует перерасчета макета и позиций элементов, а только перерисовки их внешнего вида. Однако, частые **repaint** могут значительно замедлить рендеринг страницы, особенно при сложных стилях, таких как градиенты, тени, или при работе с анимациями.

## Оптимизация процесса отрисовки:

1.  **Минимизация Repaint и Reflow**:

- Изменения, которые вызывают **repaint**, не должны происходить часто. Например, CSS-анимации, которые затрагивают такие свойства, как цвет или градиент, могут быть заменены на более производительные изменения, например, анимацию свойств `transform` или `opacity`.

2.  **Использование GPU для анимаций**:

- Свойства, такие как `transform` и `opacity`, могут быть обработаны с помощью **GPU** (графического процессора), что значительно ускоряет процесс перерисовки и улучшает производительность анимаций. Это позволяет избегать постоянного обращения к **CPU** и значительно снижает нагрузку на браузер.

3.  **Использование свойства `will-change`**:

- Указание браузеру, какие элементы планируется изменять, с помощью CSS-свойства `will-change` помогает браузеру заранее оптимизировать отрисовку для этих элементов, избегая лишних **repaint**.

4.  **Уменьшение количества слоёв**:

- Избыточное количество слоёв может усложнять процесс композиции, замедляя отрисовку. Следует избегать чрезмерного использования свойств, таких как `z-index` и сложных анимаций, если это не необходимо.

#### Заключение:

Этап **отрисовки** играет ключевую роль в визуализации страницы, преобразовывая **Render Tree** в набор пикселей на экране. Оптимизация этого процесса и минимизация повторных **repaint** и **reflow** — важный шаг для повышения производительности страницы и обеспечения плавного пользовательского опыта.

# 6. Композитинг (Compositing)

Этап **композитинга** — это финальный шаг в процессе рендеринга страницы, когда браузер объединяет слои (layers) в окончательное изображение для отображения на экране.

## Как происходит композитинг:

1. **Создание слоёв (Layers)**:

   - Браузер разделяет некоторые элементы страницы на отдельные слои, если они содержат сложные визуальные эффекты, такие как анимации, трансформации (`transform`), полупрозрачность (`opacity`), использование свойства `will-change`, а также элементы с высоким уровнем вложенности и перекрытия.
   - Элементы, влияющие на другие части документа, например, статические блоки текста, обычно не требуют выделения отдельного слоя.

2. **Почему создаются слои**:

   - Создание слоев улучшает производительность рендеринга. Если изменяется только один слой, браузер может избежать перерисовки всего документа и обновить только этот слой.
   - Элементы, использующие аппаратное ускорение (например, с анимацией через `transform` или `opacity`), рендерятся на **GPU**, что позволяет быстрее обрабатывать сложные эффекты.

3. **Комбинирование слоёв (Compositing)**:
   - После того как каждый слой был прорисован и растрирован, браузер объединяет их в одно финальное изображение. Это называется **compositing** — процесс "склейки" всех слоев в одно визуальное представление.
   - **GPU** используется для того, чтобы объединить слои, наложить их друг на друга с учетом их прозрачности, теней и других эффектов.

### Когда и как композитинг оптимизирует рендеринг:

1. **Аппаратное ускорение с использованием GPU**:

   - Некоторые эффекты и стили, такие как `transform`, `opacity`, `will-change`, или сложные анимации, обрабатываются **GPU**. Это позволяет уменьшить нагрузку на **CPU** и ускорить рендеринг.
   - Использование **GPU** для объединения слоев позволяет избежать перерисовки всего документа при изменении отдельных элементов. Например, анимации, которые меняют только **transform** или **opacity**, не требуют полной перерисовки страницы.

2. **Минимизация повторных рендеров (Repaint)**:
   - Если элементы выделены в отдельные слои, это помогает браузеру перерисовывать только измененные области, не затрагивая другие части страницы. Это особенно полезно при сложных анимациях или динамическом контенте.

### Пример:

Если на странице есть несколько элементов с CSS-анимацией `transform: translateX(100px);` и эффектом прозрачности `opacity: 0.5;`, браузер выделит их в отдельные слои и будет обновлять только эти слои во время анимации, вместо того чтобы каждый раз пересчитывать и перерисовывать весь документ.

## Способы оптимизации композитинга:

1. **Использование свойства `will-change`**:

   - Указание браузеру, какие свойства элемента могут измениться в будущем (например, `transform`, `opacity`), помогает браузеру заранее выделить элемент в отдельный слой, что ускоряет последующую обработку изменений.

2. **Избегание излишней многослойности**:

   - Хотя слои помогают ускорить отрисовку, избыточное количество слоев может замедлить процесс **compositing**, так как каждый слой требует вычислений и памяти. Важно не злоупотреблять свойствами, которые создают новые слои, такими как `z-index` и `will-change`, если это не необходимо.

3. **Оптимизация анимаций**:
   - Сложные анимации лучше всего выполнять на свойствах, которые могут быть обработаны на **GPU** — это, в первую очередь, `transform` и `opacity`. Избегайте анимации, которая затрагивает размеры элементов (`width`, `height`), так как это вызывает **reflow** и значительно замедляет рендеринг.

## Заключение:

Этап **композитинга** — это ключевой процесс, который позволяет браузеру эффективно отрисовывать сложные страницы, разделяя их на слои и используя **GPU** для быстрой обработки изменений. Оптимизация композитинга через минимизацию количества слоёв и использование аппаратного ускорения помогает улучшить производительность страницы, особенно при работе с анимациями и динамическими элементами.

# 7. Обработка и выполнение JavaScript

JavaScript играет ключевую роль в создании динамических веб-страниц, но его выполнение может существенно повлиять на производительность рендеринга. Давайте рассмотрим, как это происходит, и какие оптимизации можно использовать для улучшения взаимодействия JavaScript с процессом рендеринга.

## Как работает выполнение JavaScript:

1. **Обнаружение и загрузка**:

   - Когда браузер находит теги `<script>`, он загружает связанные скрипты (если они подключены через `src`). Если скрипт синхронный, браузер приостанавливает дальнейший парсинг HTML и выполнение рендеринга до тех пор, пока скрипт не будет загружен и выполнен.
   - Асинхронные скрипты (`async`, `defer`) загружаются параллельно с остальной страницей, но они обрабатываются в разное время:
     - **async** — загружается и выполняется, как только скрипт доступен, не дожидаясь полной загрузки документа.
     - **defer** — загружается параллельно, но выполняется после полного парсинга HTML.

2. **Влияние на DOM и CSSOM**:
   - JavaScript может изменять структуру **DOM**, добавлять или удалять элементы, изменять их атрибуты. Эти изменения могут вызвать:
     - **Reflow (Layout)** — если изменяются размеры или расположение элементов.
     - **Repaint** — если изменяются стили или визуальные эффекты без изменения геометрии.
   - Скрипты также могут изменять **CSSOM**, например, динамически добавляя стили или классы. Это может привести к необходимости пересчета стилей и заново отрисовать некоторые элементы.

## Повторное выполнение этапов рендеринга:

- После того как JavaScript изменяет **DOM** или **CSSOM**, браузеру необходимо снова пройти часть этапов рендеринга. Это может включать:
  - **Reflow** — повторный расчет макета страницы для элементов, затронутых изменениями.
  - **Repaint** — обновление внешнего вида элементов (например, цвет, шрифты).
  - **Композиция слоёв** — если были изменены элементы, которые выделены в отдельные слои.

## Оптимизация JavaScript:

1. **Асинхронная загрузка скриптов**:

   - По возможности лучше загружать JavaScript с атрибутами **async** или **defer**:
     - **async** загружает и выполняет скрипты как можно быстрее, но может выполнить их до полной загрузки HTML, что в некоторых случаях может вызвать ошибки, если элементы DOM ещё не загружены.
     - **defer** гарантирует выполнение скрипта только после полной загрузки и парсинга HTML-документа, что делает его более безопасным выбором для скриптов, взаимодействующих с DOM.

2. **Минимизация изменений DOM**:

   - Избегайте частого изменения DOM или его больших частей, так как это вызывает повторные **reflow** и **repaint**. Если изменения необходимы, постарайтесь их сгруппировать и выполнять за один раз.
   - Вставляйте или удаляйте элементы через фрагменты (DocumentFragment), чтобы минимизировать число обновлений.

3. **Динамическая работа со стилями**:

   - Избегайте инлайн-стилей или динамического изменения стилей через JavaScript, если это возможно. Старайтесь использовать классы для изменения стилей, так как это позволяет браузеру эффективнее применять изменения.
   - При изменении нескольких стилей лучше использовать `classList.toggle()` вместо прямого изменения стилей через `style`.

4. **Оптимизация рендеринга с помощью `requestAnimationFrame`**:

   - Если ваш скрипт связан с анимацией или визуальными изменениями, используйте `requestAnimationFrame` для синхронизации изменений с рендерингом, что позволит браузеру более эффективно управлять ресурсами и оптимизировать отрисовку.

5. **Разделение тяжёлых вычислений**:
   - Тяжёлые вычисления или операции, которые могут блокировать основной поток, лучше делегировать в **Web Workers**. Это позволяет разгрузить основной поток, чтобы он мог продолжать рендеринг и обрабатывать пользовательские взаимодействия без задержек.

## Заключение:

JavaScript может как улучшить динамичность и интерактивность страницы, так и значительно замедлить процесс рендеринга, если используется неправильно. Оптимизация загрузки и выполнения скриптов, а также минимизация вмешательства в **DOM** и **CSSOM**, помогает избежать ненужных **reflow**, **repaint** и улучшить производительность страницы.

# 8. Повторный рендеринг (Re-rendering)

Повторный рендеринг — это процесс, при котором браузер снова проходит через этапы рендеринга после того, как изменения были внесены в **DOM** или **CSSOM**. Это может происходить в результате выполнения JavaScript, а также взаимодействия пользователя с элементами страницы. Рассмотрим, как это происходит, и как можно оптимизировать этот процесс.

## Основные этапы повторного рендеринга:

1. **Reflow (Перерасчет макета)**:

   - **Reflow** происходит, когда изменения в **DOM** или стили элементов влияют на их размеры, положение или структуру. Например, добавление нового элемента, изменение размеров окна браузера или обновление свойств `width`, `height`, `padding`, `margin` и других параметров может привести к перерасчету макета всей страницы или её части.
   - Браузер должен повторно пройти через дерево элементов (Render Tree), чтобы рассчитать новые позиции и размеры для каждого элемента, что может быть весьма ресурсоемким.

2. **Repaint (Перерисовка)**:
   - **Repaint** происходит, когда изменяются визуальные свойства элементов, такие как цвет, фон, тень и т.д., без изменения их геометрии. Например, изменение цвета текста (`color`) или фона элемента (`background-color`) вызовет перерисовку, но не потребует перерасчета макета страницы.
   - Хотя repaint менее затратен, чем reflow, он также может повлиять на производительность, особенно если перерисовываются крупные области страницы или много элементов.

## Оптимизация повторного рендеринга:

1. **Минимизация Reflow**:

   - Избегайте частых изменений в **DOM**, особенно тех, которые могут затронуть геометрию элементов. Это поможет сократить количество перерисовок и перерасчетов макета.
   - **Группируйте изменения**: Вместо того чтобы изменять свойства элементов по одному, старайтесь выполнять все изменения за один раз. Например, измените несколько CSS-свойств через классы, а не напрямую через JavaScript.
   - Используйте **DocumentFragment** для вставки или изменения нескольких элементов за один раз, чтобы минимизировать количество операций над **DOM**.

2. **Использование CSS-анимаций**:

   - **CSS-анимации** и **трансформации** часто более производительны, чем JavaScript-анимации, так как они могут быть оптимизированы для выполнения на **GPU**. Это уменьшает нагрузку на процессор и ускоряет выполнение анимаций.
   - Свойства вроде `transform` и `opacity` могут быть изменены без необходимости вызова **reflow**, что делает их отличным выбором для анимаций.

3. **Использование `will-change`**:

   - Свойство **`will-change`** подсказывает браузеру, что конкретный элемент скоро изменится, например, его положение, размеры или прозрачность. Это позволяет браузеру подготовиться к предстоящим изменениям и заранее оптимизировать работу с элементом.
   - **Пример**: Если вы планируете анимировать элемент, можно заранее указать браузеру, что его свойство `transform` или `opacity` скоро изменится, чтобы минимизировать затраты на перерасчеты во время анимации.

   ```css
   .animated-element {
     will-change: transform, opacity;
   }
   ```
